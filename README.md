# Conways game of life in Julia

Never made anything is julia before, this is part of the CFRR course. I didn't
attend the actual workshop so I'm just doing it alone. There's likely going to
be a lot of problems with the way I'm setting my project up, but I at least 
followed a guide online for this.

## Things I like about julia

- The syntax is pretty nice, similar to lua in a lot of ways
- I appreciate the package management with its caching and such, breath of
fresh air compared to R

## Thinks I do not like about julia

- The lsp is written in julia. This sounds like it might be ok, but getting it
to actually run was a right pain and took several hours (more than it took to
write this codebase I'm sure)
- Julia being a JIT compiled language kinda hampers it a bit when it comes to
making servicable code.
    - Everything is package and module based (unless you want to go out of your
    way to avoid the design ethos).
    - You can't write a script that does something for the user. All that does
    is make a list of commands that are sent through to the REPL (which isn't 
    quite what you might actually want)
        - For example, this would mean any plots generated by a script would
        render. You'd need to explicitly set Qt (or whatever else) to be in
        headless mode.
        - I'm sure there are other problems surrounding this that I have yet
        to bump into
    - You also can't quickly and easily make a binary file for a user to work
    with either. Considering the binary files are massive (>200MB) it would be
    difficult to distribute these and also be a pain for users to compile
    themselves
    - Instead, the desired workflow appears to be:
        - Make a package
        - Get a user to add the package to their environment/project
        - Get the user to run functions from your package
    - This is fine, but is quite limited in scope. You can do this with Python
    for example too, but what if you want to make a CLI tool? Don't use Julia
    I guess.
        - And herein lies the reason I won't really be using Julia all too much


## Performance upgrades 

I didn't really think of these myself but implemented them anyways:

- Using a smaller type instead of `Int` (`Bool`)
- Creating two boards, one for holding the previous state and one for holding
the current state
    - At each iteration, the previous board is updated to the next state and
    the boards are switched.
    - This means that the board updating doesn't require any copies to be made
    - This is an actually good optimisation that is generalisable to other
    projects where some object needs to be updated through time (but can't be
    updated in place)

